import sys, itertools, timeit, os, copy                                                                                                                                                                   
import numpy as np
from yarp.taffi_functions import graph_seps,table_generator,return_rings,adjmat_to_adjlist,canon_order
from yarp.properties import el_to_an,an_to_el,el_mass
from yarp.find_lewis import find_lewis,return_formals,return_n_e_accept,return_n_e_donate,return_formals,return_connections,return_bo_dict
from yarp.hashes import atom_hash,yarpecule_hash
from yarp.input_parsers import xyz_parse,xyz_q_parse,xyz_from_smiles, mol_parse
from yarp.misc import merge_arrays, prepare_list
from openbabel import pybel
from rdkit import Chem
from rdkit.Chem import EnumerateStereoisomers, AllChem, TorsionFingerprints, rdmolops, rdDistGeom
from rdkit.Chem.EnumerateStereoisomers import EnumerateStereoisomers, StereoEnumerationOptions
from rdkit.ML.Cluster import Butina
def geometry_opt(molecule):
    """
    Geometry optimization on product side by pybel
    """
    mol_file='.tmp.mol'
    mol_write(mol_file, molecule, append_opt=False)
    mol=next(pybel.readfile("mol", mol_file))
    mol.localopt(forcefield='uff')
    for count_i, i in enumerate(molecule.geo):
        molecule.geo[count_i]=mol.atoms[count_i].coords
    os.system("rm {}".format(mol_file))
    return molecule

def mol_write(name,molecule,append_opt=False):
    elements=molecule.elements
    geo=molecule.geo
    bond_mat=molecule.bond_mats[0]
    q=molecule.q
    adj_mat=molecule.adj_mat
    # Consistency check
    if len(elements) >= 1000:
        print( "ERROR in mol_write: the V2000 format can only accomodate up to 1000 atoms per molecule.")
        return
    mol_dict={3:1, 2:2, 1:3, -1:5, -2:6, -3:7, 0:0}
    # Check for append vs overwrite condition
    if append_opt == True:
        open_cond = 'a'
    else:
        open_cond = 'w'

    # Parse the basename for the mol header
    base_name = name.split(".")
    if len(base_name) > 1:
        base_name = ".".join(base_name[:-1])
    else:
        base_name = base_name[0]

    keep_lone=[count_i for count_i, i in enumerate(bond_mat) if i[count_i]%2==1]
    # deal with radicals
    fc = list(return_formals(bond_mat, elements))
    # deal with charges 
    chrg = len([i for i in fc if i != 0])
    valence=[] # count the number of bonds for mol file
    for count_i, i in enumerate(bond_mat):
        bond=0
        for count_j, j in enumerate(i):
            if count_i!=count_j: bond=bond+int(j)
        valence.append(bond)
    # Write the file
    with open(name,open_cond) as f:
        # Write the header
        f.write('{}\nGenerated by mol_write.py\n\n'.format(base_name))

        # Write the number of atoms and bonds
        f.write("{:>3d}{:>3d}  0  0  0  0  0  0  0  0  1 V2000\n".format(len(elements),int(np.sum(adj_mat/2.0))))

        # Write the geometry
        for count_i,i in enumerate(elements):
            f.write(" {:> 9.4f} {:> 9.4f} {:> 9.4f} {:<3s} 0 {:>2d}  0  0  0  {:>2d}  0  0  0  0  0  0\n".format(geo[count_i][0],geo[count_i][1],geo[count_i][2], i.capitalize(), mol_dict[fc[count_i]], valence[count_i]))

        # Write the bonds
        bonds = [ (count_i,count_j) for count_i,i in enumerate(adj_mat) for count_j,j in enumerate(i) if j == 1 and count_j > count_i ] 
        for i in bonds:

            # Calculate bond order from the bond_mat
            bond_order = int(bond_mat[i[0],i[1]])             
            f.write("{:>3d}{:>3d}{:>3d}  0  0  0  0\n".format(i[0]+1,i[1]+1,bond_order))

        # write radical info if exist
        if len(keep_lone) > 0:
            if len(keep_lone) == 1:
                f.write("M  RAD{:>3d}{:>4d}{:>4d}\n".format(1,keep_lone[0]+1,2))
            elif len(keep_lone) == 2:
                f.write("M  RAD{:>3d}{:>4d}{:>4d}{:>4d}{:>4d}\n".format(2,keep_lone[0]+1,2,keep_lone[1]+1,2))
            else:
                print("Only support one/two radical containing compounds, radical info will be skip in the output mol file...")

        if chrg > 0:
            if chrg == 1:
                charge = [i for i in fc if i != 0][0]
                f.write("M  CHG{:>3d}{:>4d}{:>4d}\n".format(1,fc.index(charge)+1,int(charge)))
            else:
                info = "M  CHG{:>3d}".format(chrg)
                for count_c,charge in enumerate(fc):
                    if charge != 0: info += '{:>4d}{:>4d}'.format(count_c+1,int(charge))
                info += '\n'
                f.write(info)

        f.write("M  END\n$$$$\n")

    return 

def return_inchikey(molecule):
    E=molecule.elements
    G=molecule.geo
    bond_mat=molecule.bond_mats[0]
    q=molecule.q
    gs=graph_seps(molecule.adj_mat)
    adj_mat=molecule.adj_mat
    groups=[]
    loop_ind=[]
    for i in range(len(gs)):
        if i not in loop_ind:
            new_group=[count_j for count_j, j in enumerate(gs[i, :]) if j>=0]
            loop_ind += new_group
            groups+=[new_group]
    inchikey=[]
    mol=copy.deepcopy(molecule)
    for group in groups:
        N_atom=len(group)
        mol=copy.deepcopy(molecule)
        mol.elements=[E[ind] for ind in group]
        mol.bond_mats=[bond_mat[group][:, group]]
        mol.geo=np.zeros([N_atom, 3])
        mol.adj_mat=adj_mat[group][:, group]
        for count_i, i in enumerate(group): mol.geo[count_i, :]=G[i, :]
        mol_write(".tmp.mol", mol)
        mol=next(pybel.readfile("mol", ".tmp.mol"))
        inchi=mol.write(format='inchikey').strip().split()[0]
        inchikey+=[inchi]
        os.system("rm .tmp.mol")
    if len(groups) == 1:
        return inchikey[0]
    else:
        return '-'.join(sorted([i[:14] for i in inchikey]))                   
